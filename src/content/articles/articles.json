{
  "articles": [
    {
      "id": 1,
      "slug": "bangladesh-crime-analysis",
      "title": "1. Bangladesh Crime Data Analysis 2024: Insights into Metropolitan and Range Units",
      "date": "January 24, 2025",
      "tags": [
        "Power BI",
        "Data Analysis",
        "Crime Analytics",
        "Data Visualization",
        "Dashboard Design"
      ],
      "excerpt": "A comprehensive analysis of Bangladesh's crime trends in 2024, exploring patterns across metropolitan and range units through interactive Power BI dashboards.",
      "medium": "https://medium.com/@shaunmia/bangladesh-crime-data-analysis-2024-dc7c3bc27197",
      "content": "[![Read on Medium](https://img.shields.io/badge/Read%20on-Medium-12100E?style=for-the-badge&logo=medium&logoColor=white)](https://medium.com/@shaunmia/bangladesh-crime-data-analysis-2024-dc7c3bc27197)\n\n## Overview\n\nAs the world increasingly relies on data to inform critical decisions, crime analysis has emerged as a crucial area where numbers tell powerful stories. This comprehensive analysis explores Bangladesh's crime trends for 2024, revealing insights about metropolitan and range units, crime types, and temporal patterns.\n\n## Key Statistics\n\n- Total Cases: 158,000\n- Metropolitan Cases: 31,000\n- Metro vs. Range Crime Ratio: 19.46\n- Top Crime Categories:\n  - Theft\n  - Other Cases\n  - Narcotics\n  - Women & Child Repression\n\n## Dashboard Analysis\n\n### 1. Crime Trends Across Months\n\n- Peak months: March and April\n- Significant drop: July\n- Mid-year dip: Potentially due to monsoons or increased security measures\n\n### 2. Regional Crime Analysis\n\n**Metropolitan Units:**\n- DMP (Dhaka): 16,000 cases\n- CMP (Chittagong): 4,000 cases\n- RMP (Rajshahi): 2,000 cases\n\n**Range Units:**\n- Dhaka Range: 25,000 cases\n- Chittagong Range: 23,000 cases\n- Rangpur Range: 16,000 cases\n\n### 3. Top Crime Categories\n\n**Metropolitan Units (DMP):**\n- Theft: 40.71%\n- Other Cases: 36.86%\n- Narcotics: 9.56%\n\n**Range Units:**\n- High theft occurrences\n- Significant narcotics cases\n- Women & child repression cases\n\n## Key Insights\n\n1. **Metropolitan vs. Range Distribution**\n   - Urban areas show higher crime density\n   - Rural areas have more total cases but lower density\n\n2. **Seasonal Patterns**\n   - March-April peak requires increased vigilance\n   - July shows consistent decrease across regions\n\n3. **Crime Type Trends**\n   - Theft dominates across all regions\n   - Narcotics cases concentrated in specific areas\n   - Women & child repression needs targeted intervention\n\n## Actionable Recommendations\n\n1. **Resource Allocation**\n   - Focus on high-density metropolitan areas\n   - Prepare for seasonal crime spikes\n   - Deploy targeted anti-theft measures\n\n2. **Prevention Strategies**\n   - Enhance community policing\n   - Implement predictive policing\n   - Strengthen anti-narcotics operations\n\n## Resources\n\n- ðŸ“Š [Live Dashboard](https://lnkd.in/g2UWZNqP)\n- ðŸ“‚ [GitHub Repository](https://github.com/yourusername/crime-analysis)\n- ðŸ“‘ [Official Data Source](https://www.police.gov.bd)\n\n---\n\n*ðŸ’¡ View the complete analysis and interactive dashboards on [Medium](https://medium.com/@shaunmia/bangladesh-crime-data-analysis-2024-dc7c3bc27197)*"
    },
    {
      "id": 2,
      "slug": "demystifying-databases",
      "title": "2. Demystifying Databases: Choosing the Right Data Storage for Analytics and Science",
      "date": "April 15, 2025",
      "tags": [
        "Database",
        "Analytics",
        "Data Science",
        "BigQuery",
        "SQL",
        "NoSQL"
      ],
      "excerpt": "A comprehensive guide to choosing the right database system for your data analytics and science projects, comparing RDBMS, NoSQL, and specialized tools like Google BigQuery.",
      "medium": "https://medium.com/@shaunmia/demystifying-databases-choosing-the-right-data-storage-for-analytics-and-science-a944f09ca15a",
      "content": "[![Read on Medium](https://img.shields.io/badge/Read%20on-Medium-12100E?style=for-the-badge&logo=medium&logoColor=white)](https://medium.com/@shaunmia/demystifying-databases-choosing-the-right-data-storage-for-analytics-and-science-a944f09ca15a)\n\n## Introduction\n\nIn today's data-driven world, the choices you make about how to store and manage data can shape the success of your projects. Whether you're building dashboards, cleaning datasets, or running predictive models, the type of database you choose impacts performance, scalability, and flexibility. This article breaks down the key types of databasesâ€”RDBMS, NoSQL, and specialized tools like Google BigQueryâ€”explaining their strengths, weaknesses, and ideal use cases for data analytics and data science workflows.\n\n## What is a Database, Anyway?\n\nAt its core, a database is an organized system for storing, managing, and retrieving data. Think of it as a digital filing cabinet, but with superpowers: it can handle massive amounts of information, enforce rules to keep data consistent, and let you query it to find exactly what you need. Databases are the backbone of everything from financial systems to social media platforms to machine learning pipelines.\n\nThe two main categories we'll explore are Relational Database Management Systems (RDBMS) and NoSQL databases, with a nod to specialized tools like Google BigQuery for big data analytics.\n\n## Understanding RDBMS: The Structured Powerhouse\n\nA Relational Database Management System (RDBMS) organizes data into structured tables, much like a collection of spreadsheets. Each table contains rows and columns, and tables can be linked through specific columns called keys. If you've ever used Excel but wished it could enforce rules, handle relationships between datasets, and run lightning-fast queries, an RDBMS is what you're imagining.\n\n### Key Features of RDBMS\n\n1. **Structured Schema**: Before you add data, you define a schemaâ€”a blueprint that specifies the columns in each table, their data types (e.g., text, numbers, dates), and constraints (e.g., no null values allowed).\n\n2. **Relationships**: Tables are connected using primary keys (unique identifiers for each row) and foreign keys (references to primary keys in other tables). For example, an 'Orders' table might link to a 'Customers' table via a Customer ID.\n\n3. **SQL as the Language**: RDBMS uses Structured Query Language (SQL) to create, update, and query data. SQL is powerful for joining tables, filtering rows, and aggregating data (e.g., calculating averages or sums).\n\n4. **Examples**: Popular RDBMS include MySQL, PostgreSQL, Oracle Database, and Microsoft SQL Server.\n\n### The ACID Guarantee\n\nRDBMS databases are built to ensure data reliability through four principles known as ACID:\n\n- **Atomicity**: Every transaction (e.g., transferring money between accounts) is treated as a single, indivisible unit. If any part fails, the whole transaction is rolled back.\n- **Consistency**: After a transaction, the database remains in a valid state, adhering to all rules and constraints (e.g., balances can't go negative).\n- **Isolation**: Transactions running at the same time don't interfere with each other. Partial changes are hidden until the transaction is complete.\n- **Durability**: Once a transaction is committed, it's permanently saved, even if the system crashes immediately after.\n\nThese properties make RDBMS a go-to choice for systems where data accuracy is critical, like banking, inventory management, or user account systems.\n\n## NoSQL Databases: Flexibility at Scale\n\nWhile RDBMS is great for structured data, not all data fits neatly into tables. Enter NoSQL databases, designed for flexibility, scalability, and handling diverse data types. NoSQL stands for 'Not Only SQL,' meaning it can support SQL-like queries but isn't limited to the rigid structure of relational databases.\n\n### Types of NoSQL Databases\n\n1. **Document Databases** (e.g., MongoDB, CouchDB):\n   - Store data as JSON-like documents, which are flexible and can have nested structures.\n   - Ideal for semi-structured data, like user profiles or product catalogs.\n   - Example: A document might store a customer's name, address, and purchase history in one object.\n\n2. **Key-Value Stores** (e.g., Redis, DynamoDB):\n   - The simplest NoSQL type, storing data as key-value pairs (like a Python dictionary).\n   - Perfect for caching, session management, or real-time analytics.\n   - Example: A key like 'user123' might map to a value like '{name: Alice, age: 30}'.\n\n3. **Wide-Column Stores** (e.g., Cassandra, HBase):\n   - Organize data into columns rather than rows, optimized for massive datasets and fast reads/writes.\n   - Great for time-series data, like IoT sensor readings or log files.\n\n4. **Graph Databases** (e.g., Neo4j, ArangoDB):\n   - Store data as nodes and edges, perfect for modeling relationships like social networks or recommendation systems.\n   - Example: A graph might show how users are connected through friendships or shared interests.\n\n### The BASE Approach\n\nUnlike RDBMS's strict ACID rules, NoSQL databases often follow BASE principles, prioritizing availability and scalability:\n\n- **Basically Available**: The system is always accessible, even if some nodes fail.\n- **Soft State**: Data might be temporarily inconsistent as updates propagate.\n- **Eventual Consistency**: Given enough time, all nodes will sync up and reflect the same data.\n\nThis trade-off makes NoSQL ideal for applications where speed and scale matter more than immediate consistency, like real-time analytics or social media feeds.\n\n## RDBMS vs. NoSQL: A Side-by-Side Comparison\n\nLet's compare the key differences between RDBMS and NoSQL databases:\n\n### Data Structure\n- **RDBMS**: Tables with fixed schema, predefined columns and data types\n- **NoSQL**: Flexible formats including documents, key-value pairs, wide columns, and graphs\n\n### Query Language\n- **RDBMS**: Standard SQL syntax across all platforms\n- **NoSQL**: Varies by database (MongoDB queries, CQL, etc.)\n\n### Scalability\n- **RDBMS**: Vertical scaling (bigger servers)\n- **NoSQL**: Horizontal scaling (more servers)\n\n### Consistency\n- **RDBMS**: Strong consistency (ACID properties)\n- **NoSQL**: Eventually consistent (BASE principles)\n\n### Use Cases\n- **RDBMS**: Structured analytics, business intelligence, financial systems\n- **NoSQL**: Big data applications, real-time analytics, high-velocity data\n\n### Pro Tip: Consider a Hybrid Approach\n\nMany modern applications benefit from using both types of databases:\n\nâœ¨ **RDBMS Strong Points**:\n- Clean, structured data storage\n- Complex reporting and analytics\n- Financial transactions and records\n\nâœ¨ **NoSQL Strong Points**:\n- Raw data ingestion\n- High-velocity logging\n- Real-time analytics\n\nðŸ”¥ **Best Practice**: Consider using both in a pipeline:\n1. Ingest raw data into NoSQL for flexibility\n2. Process and structure the data\n3. Store cleaned results in RDBMS for analysis\n\n## Google BigQuery: The Big Data Game-Changer\n\nFor data scientists and analysts working with massive datasets, Google BigQuery is a standout tool. BigQuery is a serverless data warehouse on Google Cloud, designed for fast, scalable analytics without the hassle of managing infrastructure.\n\n### Why BigQuery Stands Out\n\n1. **Serverless**: No need to set up or maintain serversâ€”Google handles everything.\n2. **SQL-Friendly**: Uses standard SQL, so you can jump in without learning a new language.\n3. **Blazing Fast**: Processes terabytes of data in seconds, thanks to Google's infrastructure.\n4. **Integration**: Works seamlessly with tools like Google Colab, Looker Studio, Python, and Jupyter Notebooks.\n5. **Cost-Effective**: Pay only for the storage and queries you use (though costs can add up for heavy usage).\n\n### BigQuery Use Cases\n\n- **Exploratory Analysis**: Query public datasets (e.g., COVID-19 stats, e-commerce trends) to uncover insights.\n- **Customer Analytics**: Run cohort analysis, churn prediction, or segmentation on large user datasets.\n- **Dashboards**: Connect BigQuery to BI tools for real-time reporting.\n- **Machine Learning**: Feed processed data into models for forecasting or classification.\n\nFor example, imagine you're analyzing a retail dataset with millions of transactions. With BigQuery, you can:\n- Write a SQL query to group sales by region and product.\n- Visualize the results in Looker Studio.\n- Export aggregates to Python for predictive modelingâ€”all in minutes.\n\n## How to Choose the Right Database\n\nBefore picking a database, ask yourself these questions:\n\n1. **What's the structure of my data?**\n   - Structured (tables) â†’ RDBMS\n   - Semi-structured (JSON, logs) â†’ NoSQL\n   - Massive and varied â†’ BigQuery or NoSQL\n\n2. **How important is consistency?**\n   - Critical (e.g., financial transactions) â†’ RDBMS\n   - Flexible (e.g., social media analytics) â†’ NoSQL\n\n3. **What's my scale?**\n   - Small to medium datasets â†’ RDBMS\n   - Huge datasets or high traffic â†’ NoSQL or BigQuery\n\n4. **What tools am I using?**\n   - SQL-based BI tools â†’ RDBMS or BigQuery\n   - Python/ML pipelines â†’ NoSQL or BigQuery\n\n### A Decision Framework\n\n**For Data Analysts:**\n- Use PostgreSQL or MySQL for clean, structured data and SQL-based reporting.\n- Use BigQuery for large-scale analytics or public datasets.\n\n**For Data Scientists:**\n- Use MongoDB or Cassandra for raw, unstructured data during preprocessing.\n- Use BigQuery for scalable feature engineering or model training datasets.\n- Use PostgreSQL for storing final, structured results.\n\n## Final Thoughts\n\nChoosing the right database isn't just a technical decisionâ€”it's a strategic one. The way you store and access data affects how quickly you can derive insights, how scalable your pipeline is, and how reliable your results are. By understanding the strengths of RDBMS (structure and consistency), NoSQL (flexibility and scale), and tools like BigQuery (big data analytics), you can build workflows that are both efficient and future-proof.\n\nSo, next time you're about to write a query or design a pipeline, pause and ask: 'Where is my data stored, and why?' The answer will guide you to cleaner data, better models, and faster insights.\n\n---\n\n*Found this helpful? [Read the complete guide on Medium](https://medium.com/@shaunmia/demystifying-databases-choosing-the-right-data-storage-for-analytics-and-science-a944f09ca15a)*"
    },
    {
      "id": 3,
      "slug": "easy-guide-to-bigquery",
      "title": "3. Easy Guide to Google BigQuery: Using SQL in the Cloud",
      "date": "April 16, 2025",
      "tags": [
        "BigQuery",
        "SQL",
        "Cloud Computing",
        "Data Analysis",
        "Google Cloud",
        "Tutorial"
      ],
      "excerpt": "A comprehensive beginner-friendly guide to using Google BigQuery for analyzing large datasets in the cloud, with practical examples and cost optimization strategies.",
      "medium": "https://medium.com/@shaunmia/easy-guide-to-google-bigquery-using-sql-in-the-cloud-e020cb7d59f3",
      "content": "[![Read on Medium](https://img.shields.io/badge/Read%20on-Medium-12100E?style=for-the-badge&logo=medium&logoColor=white)](https://medium.com/@shaunmia/easy-guide-to-google-bigquery-using-sql-in-the-cloud-e020cb7d59f3)\n\n## Introduction\n\nIn today's digital world, data is growing fastâ€”and analyzing large amounts of it can be a challenge. Traditional databases like MySQL or PostgreSQL often struggle when the data becomes too large. That's where Google BigQuery comes in.\n\nBigQuery is a cloud-based data warehouse built by Google. It's designed to handle huge amounts of data quickly and efficiently using SQL, the most popular language for querying databases. Even better, there's no need to manage servers or complex infrastructure.\n\n## ðŸ” What is Google BigQuery?\n\nGoogle BigQuery is part of the Google Cloud Platform (GCP). It's a powerful tool that allows users to:\n\n- Store massive datasets\n- Run super-fast SQL queries\n- Visualize and analyze data\n- Integrate with tools like Python, Google Data Studio, and more\n\nIt's used in industries like e-commerce, healthcare, finance, and marketing for tasks such as business reporting, trend analysis, machine learning, and predictive analytics.\n\n## ðŸš€ Why Use BigQuery?\n\nHere's what makes BigQuery stand out:\n\n- **Lightning Fast**: Query billions of rows in just seconds\n- **No Setup Required**: Everything runs in the cloud\n- **Massive Storage**: Easily store petabytes of data\n- **Flexible Integrations**: Works with many tools\n- **Free Public Datasets**: Access real-world data\n\n## ðŸ§± BigQuery Structure\n\n### Project\nA container that holds all your datasets, tables, and resources. Think of it like a big folder.\n\n### Dataset\nA collection of related tables. For example, a dataset called store_data might include customer, sales, and inventory tables.\n\n### Table\nThe actual data is stored in tables, just like in Excelâ€”rows and columns.\n\n### Schema\nThe structure of a table. It defines each column's data type and requirements.\n\n## ðŸ› ï¸ How to Use BigQuery\n\nThere are several ways to use BigQuery:\n\n1. **BigQuery Console** (browser-based)\n2. **Command Line Tool** (bq CLI)\n3. **Jupyter or Google Colab Notebooks**\n4. **Data Visualization Tools**\n5. **Applications** via APIs\n\n## Writing SQL Queries\n\n```sql\nSELECT \n  start_station_name,\n  COUNT(*) AS ride_count\nFROM \n  `bigquery-public-data.london_bicycles.cycle_hire`\nGROUP BY \n  start_station_name\nORDER BY \n  ride_count DESC\nLIMIT 10;\n```\n\n## ðŸ’° BigQuery Pricing\n\n### Free Tier\n- 1 TB free queries per month\n- Free public datasets\n- Perfect for learning\n\n### Cost-Saving Tips\n1. Use specific columns instead of SELECT *\n2. Check data size before querying\n3. Use EXPLAIN to estimate costs\n4. Set up billing alerts\n\n## ðŸ†š BigQuery vs. Traditional Databases\n\n### Feature Comparison\n\n**Setup and Maintenance**\n- Traditional Databases: Manual server setup, ongoing maintenance required\n- BigQuery: Fully managed, no setup needed, automatic updates\n\n**Storage Architecture**\n- Traditional Databases: Row-based storage, optimized for transactions\n- BigQuery: Columnar storage, optimized for analytics and fast queries\n\n**Performance at Scale**\n- Traditional Databases: Performance degrades with large datasets\n- BigQuery: Maintains speed even with petabyte-scale data\n\n**Cost Structure**\n- Traditional Databases: Fixed costs for hardware and licenses\n- BigQuery: Pay-per-use model, only charged for queries run\n\n**Best Use Cases**\n- Traditional Databases: Live applications, OLTP workloads\n- BigQuery: Large-scale analytics, data warehousing\n\n### Key Differences Summary\n\nâœ¨ **Infrastructure Management**\n- Traditional: Manual scaling and maintenance\n- BigQuery: Automatic scaling, zero maintenance\n\nðŸš€ **Query Performance**\n- Traditional: Index-dependent, can be slow for large datasets\n- BigQuery: Distributed processing, consistently fast\n\nðŸ’° **Cost Model**\n- Traditional: Fixed infrastructure costs\n- BigQuery: Pay only for what you use\n\nðŸ”„ **Data Processing**\n- Traditional: Better for real-time updates\n- BigQuery: Optimized for batch analytics\n\n## ðŸ“Š Real-World Applications\n\n### Data Analysis\n- Customer segmentation\n- Sales forecasting\n- Trend analysis\n- Performance monitoring\n\n### Business Intelligence\n- Real-time dashboards\n- KPI tracking\n- Revenue analysis\n- Market insights\n\n### Machine Learning\n- Predictive modeling\n- Pattern recognition\n- Anomaly detection\n- Customer behavior analysis\n\n## âš ï¸ Best Practices\n\n1. **Query Optimization**\n   - Use appropriate columns\n   - Filter early\n   - Optimize JOINs\n\n2. **Cost Management**\n   - Monitor usage\n   - Use table previews\n   - Implement quotas\n\n3. **Performance Tips**\n   - Partition tables\n   - Use clustering\n   - Cache results\n\n## âœ… Getting Started\n\n1. Create a Google Cloud account\n2. Enable BigQuery API\n3. Explore public datasets\n4. Write your first query\n\n## Additional Resources\n\n- ðŸ“š [Official Documentation](https://cloud.google.com/bigquery/docs)\n- ðŸŽ“ [Google Cloud Training](https://cloud.google.com/training/data-sql)\n- ðŸ’¡ [Sample Queries](https://cloud.google.com/bigquery/docs/samples)\n- ðŸ” [Best Practices Guide](https://cloud.google.com/bigquery/docs/best-practices-performance-overview)\n\n---\n\n*Found this helpful? [Read the complete guide on Medium](https://medium.com/@shaunmia/easy-guide-to-google-bigquery-using-sql-in-the-cloud-e020cb7d59f3)*"
    },
    {
      "id": 4,
      "slug": "mysql-setup-guide",
      "title": "4. Simple Guide to Setting Up MySQL and Learning SQL Commands",
      "date": "April 18, 2025",
      "tags": [
        "MySQL",
        "SQL",
        "Database",
        "Tutorial",
        "Programming"
      ],
      "excerpt": "A beginner-friendly guide to installing MySQL, understanding database structures, and mastering essential SQL commands with practical examples.",
      "medium": "https://medium.com/@shaunmia/simple-guide-to-setting-up-mysql-and-learning-sql-commands-94ab79d31ad2",
      "content": "[![Read on Medium](https://img.shields.io/badge/Read%20on-Medium-12100E?style=for-the-badge&logo=medium&logoColor=white)](https://medium.com/@shaunmia/simple-guide-to-setting-up-mysql-and-learning-sql-commands-94ab79d31ad2)\n\n## Introduction\n\nIf you're getting into data analysis, app development, or data science, SQL is a skill you need to learn. It's a language that helps you talk to databases and pull out useful information. But before you can start asking questions of your data, you need to set up a database and understand the basic commands. In this guide, we'll walk you through setting up MySQL (a popular database tool) and explain the different types of SQL commands in a simple way.\n\nHere's what we'll cover:\n\n- How to install MySQL and a tool called Workbench to work with it.\n- What a database structure looks like (schemas, tables, and more).\n- The five main types of SQL commands and what they do.\n- How to use these commands in real-life data projects.\n\n## Step 1: Installing MySQL and Workbench\n\nTo work with SQL, you need two things:\n\n- **MySQL Server**: This is the program that stores and manages your data.\n- **MySQL Workbench**: A tool that lets you write SQL commands and see your data easily.\n\n### How to Install\n\n1. Go to the MySQL website at https://dev.mysql.com/downloads/.\n2. Look for the MySQL Installer â€” it's a package that includes both the server and Workbench.\n3. Download and run the installer. It'll ask you to pick what to install â€” just choose the server and Workbench, and follow the steps.\n4. During setup, you'll create a password for the \"root\" user (the main account for MySQL). Don't forget it!\n5. Once everything is installed, open MySQL Workbench. It looks like a control panel where you can connect to your MySQL server. Enter your root password to log in, and you're ready to start creating and exploring databases.\n\n## Step 2: Understanding Databases: Schemas, Tables, and More\n\nBefore we jump into commands, let's talk about how a database is organized. Think of it like a filing system:\n\n- **Schema**: This is like a big folder that holds everything. It's a way to group related stuff together.\n- **Table**: Inside the schema, tables are like spreadsheets. They store your data in rows and columns.\n- **Field (or Column)**: These are the headers in your table, like \"Name\" or \"Age.\" Each field holds one type of information.\n- **Row**: A row is one entry in the table â€” like one person's info.\n\nFor example, imagine a schema called school. Inside it, you might have a table called students with fields like id, name, and age. Each row in the table would be one student, like \"1, John, 15.\"\n\nUnderstanding this structure helps you know where your data lives and how to work with it.\n\n## Step 3: The Five Types of SQL Commands\n\nSQL commands are like instructions you give to the database. They're grouped into five main types based on what they do. Let's break them down in simple terms.\n\n### 1. DDL (Data Definition Language): Building the Structure\n\nThese commands help you create or change the structure of your database â€” like making new tables or deleting them.\n\n- **CREATE**: Makes a new table or schema.\n- **ALTER**: Changes a table, like adding a new column.\n- **DROP**: Deletes a table or schema completely.\n- **TRUNCATE**: Clears all the data from a table but keeps the table itself.\n\nHere's an example of creating a table for students:\n\n```sql\nCREATE TABLE students (\n    id INT,\n    name VARCHAR(100)\n);\n```\n\nThis makes a table called students with two columns: id (a number) and name (text that can be up to 100 letters long).\n\n### 2. DML (Data Manipulation Language): Working with Data\n\nThese commands let you add, change, or remove data inside your tables.\n\n- **INSERT**: Adds new data.\n- **UPDATE**: Changes existing data.\n- **DELETE**: Removes data.\n\nHere's how to add a student to the table:\n\n```sql\nINSERT INTO students (id, name)\nVALUES (1, 'John Smith');\n```\n\nAnd here's how to update their name:\n\n```sql\nUPDATE students\nSET name = 'Johnny Smith'\nWHERE id = 1;\n```\n\n### 3. DCL (Data Control Language): Managing Access\n\nThese commands control who can use the database and what they can do.\n\n- **GRANT**: Gives someone permission to do something.\n- **REVOKE**: Takes away permission.\n\nExample of giving someone read access:\n\n```sql\nGRANT SELECT ON school.students TO 'user'@'localhost';\n```\n\n### 4. TCL (Transaction Control Language): Keeping Changes Safe\n\nThese commands help you manage changes to your data:\n\n- **COMMIT**: Saves your changes permanently.\n- **ROLLBACK**: Undoes changes you haven't committed yet.\n- **SAVEPOINT**: Creates a point you can roll back to.\n\n```sql\nBEGIN;\nUPDATE students SET grade = grade + 1;\nCOMMIT;\n```\n\n### 5. DQL (Data Query Language): Getting Information\n\nThis is how you ask questions about your data:\n\n- **SELECT**: Gets data from tables.\n\n```sql\nSELECT name, grade\nFROM students\nWHERE grade >= 90\nORDER BY name;\n```\n\n## Step 4: How to Use SQL in Real Projects\n\nNow that you know the commands, here's how to use them in real projects:\n\n1. **Set Up Your Structure**\n   - Create your database and tables\n   - Plan your data organization\n   - Set up relationships between tables\n\n2. **Add Your Data**\n   - Insert initial data\n   - Import data from files\n   - Update existing records\n\n3. **Write Queries**\n   - Filter and sort data\n   - Join related tables\n   - Calculate summaries\n\n4. **Manage Access**\n   - Set up user accounts\n   - Control permissions\n   - Monitor usage\n\n## Common Examples\n\n### Creating a Database\n```sql\nCREATE DATABASE school;\nUSE school;\n```\n\n### Creating Tables with Relationships\n```sql\nCREATE TABLE classes (\n    class_id INT PRIMARY KEY,\n    class_name VARCHAR(50)\n);\n\nCREATE TABLE students (\n    student_id INT PRIMARY KEY,\n    name VARCHAR(100),\n    class_id INT,\n    FOREIGN KEY (class_id) REFERENCES classes(class_id)\n);\n```\n\n### Basic Queries\n```sql\n-- Get all students in a class\nSELECT s.name, c.class_name\nFROM students s\nJOIN classes c ON s.class_id = c.class_id;\n\n-- Count students per class\nSELECT c.class_name, COUNT(*) as student_count\nFROM classes c\nJOIN students s ON c.class_id = s.class_id\nGROUP BY c.class_name;\n```\n\n## Best Practices\n\n1. **Planning**\n   - Design your database structure first\n   - Think about relationships between data\n   - Consider future needs\n\n2. **Security**\n   - Use strong passwords\n   - Limit user permissions\n   - Back up your data regularly\n\n3. **Performance**\n   - Create proper indexes\n   - Write efficient queries\n   - Monitor database size\n\n## Troubleshooting Tips\n\n1. **Common Errors**\n   - Check syntax carefully\n   - Verify table and column names\n   - Ensure data types match\n\n2. **Performance Issues**\n   - Use EXPLAIN to analyze queries\n   - Check indexes\n   - Monitor server resources\n\n## Resources for Learning More\n\n- ðŸ“š [MySQL Documentation](https://dev.mysql.com/doc/)\n- ðŸ’» [W3Schools SQL Tutorial](https://www.w3schools.com/sql/)\n- ðŸŽ“ [MySQL Workbench Guide](https://dev.mysql.com/doc/workbench/en/)\n\n## Conclusion\n\nStarting with MySQL might seem overwhelming, but by understanding these basic concepts and commands, you're well on your way to working with databases effectively. Remember to practice regularly and start with simple projects before moving on to more complex ones.\n\n---\n\n*Found this helpful? [Read the complete guide on Medium](https://medium.com/@shaunmia/simple-guide-to-setting-up-mysql-and-learning-sql-commands-94ab79d31ad2)*"
    },
    {
      "id": 5,
      "slug": "sql-foundation",
      "title": "5. Constraints, Data Types & Keys â€” Building a Solid SQL Foundation",
      "date": "April 21, 2025",
      "tags": [
        "SQL",
        "Database",
        "Data Types",
        "Constraints",
        "Database Design"
      ],
      "excerpt": "A comprehensive guide to SQL constraints, data types, and keys - the fundamental building blocks for designing efficient and reliable database structures.",
      "medium": "https://medium.com/@shaunmia/constraints-data-types-keys-building-a-solid-sql-foundation-597ee42621fd",
      "content": "[![Read on Medium](https://img.shields.io/badge/Read%20on-Medium-12100E?style=for-the-badge&logo=medium&logoColor=white)](https://medium.com/@shaunmia/constraints-data-types-keys-building-a-solid-sql-foundation-597ee42621fd)\n\n## Introduction\n\nWhen working with databases, writing good SQL isn't just about querying data â€” it starts with designing a solid structure. That structure depends heavily on constraints, data types, and keys. In this article, we'll explore how these foundational concepts help maintain accuracy, consistency, and scalability in real-world projects.\n\n## 1. Understanding SQL Keys: The Backbone of Relational Databases\n\n### Primary Key\n\nA Primary Key is a unique identifier for each record in a table. It:\n\n- Must contain unique values\n- Cannot contain NULL values\n- Is often a column like id or user_id\n\nExample:\n\n```sql\nCREATE TABLE users (\n  user_id INT PRIMARY KEY,\n  name VARCHAR(100)\n);\n```\n\n### Foreign Key\n\nA Foreign Key is used to link two tables. It ensures referential integrity, meaning the value must exist in the referenced table.\n\nExample:\n\n```sql\nCREATE TABLE orders (\n  order_id INT PRIMARY KEY,\n  user_id INT,\n  FOREIGN KEY (user_id) REFERENCES users(user_id)\n);\n```\n\n### Unique Constraint\n\nEnsures all values in a column are different â€” often used for fields like email or username.\n\n```sql\nCREATE TABLE employees (\n  emp_id INT PRIMARY KEY,\n  email VARCHAR(255) UNIQUE\n);\n```\n\n## 2. Other Essential SQL Constraints\n\n### NOT NULL\n\nPrevents NULL values in a column. Useful for mandatory fields.\n\n```sql\nname VARCHAR(100) NOT NULL\n```\n\n### AUTO_INCREMENT\n\nAutomatically increases the value of a numeric column, often used for IDs.\n\n```sql\nuser_id INT AUTO_INCREMENT PRIMARY KEY\n```\n\n### CHECK Constraint\n\nLimits the range of values. Great for validations like age or scores.\n\n```sql\nage INT CHECK (age >= 18)\n```\n\n### ðŸ§¾ DEFAULT Value\n\nSets a default value if none is provided during insert.\n\n```sql\nstatus VARCHAR(20) DEFAULT 'Pending'\n```\n\n## 3. Common Data Types in SQL\n\nChoosing the right data type ensures that your database is both efficient and accurate.\n\n| Data Type | Description | Example |\n|-----------|-------------|----------|\n| INT | Integer numbers | 100, -10 |\n| FLOAT | Decimal numbers | 3.14, -2.71 |\n| VARCHAR | Variable-length text | 'Hello World' |\n| CHAR | Fixed-length text | 'A', 'Yes' |\n| DATE | Date values | '2025-04-15' |\n| BOOLEAN | True/False | TRUE, FALSE |\n| TEXT | Long form text | Articles, notes |\n\n## 4. Schema Planning Tips for Real-World Projects\n\nBefore writing any SQL, consider these best practices:\n\n### Define Your Entities Clearly\n\nThink in terms of real-world objects: users, products, orders, etc. Each should be a table.\n\n### ðŸ”— Use Relationships Wisely\n\nNormalize your schema by splitting repeating data into related tables with foreign keys.\n\n### Choose the Right Data Types\n\nAvoid using TEXT where VARCHAR(255) will do. Be specific to reduce storage and improve performance.\n\n### Add Constraints Thoughtfully\n\nUse constraints to prevent bad data â€” they are your first line of defense before code validations.\n\n## Wrap-Up\n\nUnderstanding constraints, data types, and keys is essential to writing scalable, secure, and efficient SQL. Whether you're designing a customer database or building a dashboard, the principles here will help you craft reliable data systems from the ground up.\n\n---\n\n*Found this helpful? [Read the complete guide on Medium](https://medium.com/@shaunmia/constraints-data-types-keys-building-a-solid-sql-foundation-597ee42621fd)*"
    },
    {
      "id": 6,
      "slug": "sql-optimization-guide",
      "title": "6. Simple Guide to Bulk Inserts, Indexing and Optimizing Your Database",
      "date": "May 3, 2025",
      "tags": [
        "SQL",
        "Database",
        "Performance",
        "Tutorial"
      ],
      "excerpt": "A comprehensive guide on database optimization techniques including bulk inserts, indexing, and partitioning for better performance.",
      "medium": "https://medium.com/@shaunmia/simple-guide-to-bulk-inserts-indexing-and-optimizing-your-database-6dc7bce332e7",
      "content": "[![Read on Medium](https://img.shields.io/badge/Read%20on-Medium-12100E?style=for-the-badge&logo=medium&logoColor=white)](https://medium.com/@shaunmia/simple-guide-to-bulk-inserts-indexing-and-optimizing-your-database-6dc7bce332e7)\n\n# Simple Guide to Bulk Inserts, Indexing and Optimizing Your Database\n\nWelcome to the fifth part of our SQL series for data professionals! In this article, we'll explore how to speed up and optimize your database when working with large datasets. Whether you're a data analyst, app developer, or aspiring data scientist, these techniques will help keep your database fast, clean, and efficient.\n\n## âœ… What We'll Cover\n\n1. Creating and modifying tables with SQL (DDL)\n2. Inserting large amounts of data (bulk insert techniques)\n3. Handling errors during imports\n4. Making your database faster with indexing and partitioning\n5. Why it all matters â€” a quick wrap-up\n\n## 1ï¸âƒ£ Creating and Changing Tables (DDL Hands-On)\n\nTo define or update your database structure, we use Data Definition Language (DDL).\n\n### Basic Commands\n\n**CREATE TABLE** â€“ Creates a new table\n\n```sql\nCREATE TABLE books (\n    book_id INT,\n    title VARCHAR(200),\n    author VARCHAR(100)\n);\n```\n\n**ALTER TABLE** â€“ Modify existing tables\n\n```sql\nALTER TABLE books ADD price DECIMAL(5,2); -- Add a column\nALTER TABLE books DROP COLUMN price;      -- Remove a column\nALTER TABLE books MODIFY book_id INT NOT NULL; -- Add constraint\nALTER TABLE books RENAME COLUMN title TO book_title; -- Rename column\nALTER TABLE books RENAME TO library_books; -- Rename table\n```\n\n**DROP TABLE** â€“ Permanently deletes a table\n\n```sql\nDROP TABLE books;\n```\n\nThese commands let you evolve your database without losing existing data.\n\n## 2ï¸âƒ£ Adding Lots of Data Quickly (Bulk Inserts)\n\nInstead of inserting data row by row, bulk insert allows importing thousands of records in seconds.\n\n### ðŸ”¹ Method 1: LOAD DATA INFILE\n\n```sql\nLOAD DATA INFILE 'path/to/books.csv'\nINTO TABLE books\nFIELDS TERMINATED BY ',' \nLINES TERMINATED BY '\\n'\nIGNORE 1 ROWS;\n```\n\n### ðŸ”¹ Method 2: Using Import Tools\n\n- Tools like MySQL Workbench or DBeaver let you import CSV files via UI.\n- Example: Right-click table > Import > Select file.\n\n### ðŸ”¹ Method 3: Using Python\n\n```python\nimport mysql.connector, csv\ndb = mysql.connector.connect(host=\"localhost\", user=\"root\", password=\"\", database=\"library\")\ncursor = db.cursor()\nwith open('books.csv', 'r') as file:\n    reader = csv.reader(file)\n    next(reader)\n    for row in reader:\n        cursor.execute(\"INSERT INTO books (book_id, title, author) VALUES (%s, %s, %s)\", row)\ndb.commit()\ncursor.close()\ndb.close()\n```\n\n### ðŸ”¹ Handling Special Characters\n\n```sql\nFIELDS TERMINATED BY ',' \nENCLOSED BY '\"' \nLINES TERMINATED BY '\\n'\n```\n\n## 3ï¸âƒ£ Fixing Problems During Bulk Insert\n\nErrors happen â€” be ready to deal with them.\n\n### ðŸ”¹ Use Error Logs\n\n```sql\nLOAD DATA INFILE 'path/to/books.csv'\nINTO TABLE books\nFIELDS TERMINATED BY ','\nLINES TERMINATED BY '\\n'\nIGNORE 1 ROWS\nSET @error_log = 'path/to/error_log.txt';\n```\n\n### ðŸ”¹ Handling Duplicates\n\n- IGNORE â€“ Skips duplicates\n- REPLACE â€“ Overwrites duplicates\n\n```sql\nLOAD DATA INFILE 'books.csv'\nINTO TABLE books\nIGNORE;\n```\n\n### ðŸ”¹ Validate Before Importing\n\n- Open CSV in Excel or Google Sheets to check format consistency.\n\n### ðŸ”¹ Use Transactions to Roll Back on Error\n\n```sql\nSTART TRANSACTION;\n-- Try importing\nLOAD DATA INFILE 'books.csv'\nINTO TABLE books\nFIELDS TERMINATED BY ','\nLINES TERMINATED BY '\\n'\nIGNORE 1 ROWS;\n-- On success:\nCOMMIT;\n-- On error:\nROLLBACK;\n```\n\n## 4ï¸âƒ£ Making Your Database Faster (Indexing & Partitioning)\n\n### ðŸ” What Is Indexing?\n\nIndexes act like bookmarks in your database â€” making searches lightning-fast.\n\n### ðŸ”¹ Create Indexes\n\n```sql\nCREATE INDEX idx_book_id ON books(book_id); -- Basic index\nCREATE INDEX idx_author_title ON books(author, title); -- Composite index\nCREATE UNIQUE INDEX idx_unique_id ON books(book_id); -- No duplicate book_id\nCREATE FULLTEXT INDEX idx_title ON books(title); -- For full-text search\n```\n\n### ðŸ”¹ Check If Index Is Used\n\n```sql\nEXPLAIN SELECT * FROM books WHERE book_id = 123;\n```\n\n### ðŸ§© What Is Partitioning?\n\nPartitioning splits huge tables into smaller chunks to improve performance.\n\n### ðŸ”¹ Range Partitioning (e.g., by year)\n\n```sql\nCREATE TABLE sales (\n    sale_id INT,\n    sale_date DATE,\n    amount DECIMAL(10,2)\n)\nPARTITION BY RANGE (YEAR(sale_date)) (\n    PARTITION p0 VALUES LESS THAN (2020),\n    PARTITION p1 VALUES LESS THAN (2021),\n    PARTITION p2 VALUES LESS THAN (2022),\n    PARTITION p3 VALUES LESS THAN MAXVALUE\n);\n```\n\n### ðŸ”¹ List Partitioning (e.g., by country)\n\n```sql\nCREATE TABLE customers (\n    customer_id INT,\n    name VARCHAR(100),\n    country VARCHAR(50)\n)\nPARTITION BY LIST (country) (\n    PARTITION p_usa VALUES IN ('USA'),\n    PARTITION p_eu VALUES IN ('France', 'Germany'),\n    PARTITION p_asia VALUES IN ('India', 'China')\n);\n```\n\n## ðŸ Wrapping Up\n\nIn this article, we explored how to optimize your database workflows with:\n\n- âœ… Table creation and schema changes using DDL\n- âš¡ Fast data uploads using bulk insert techniques\n- ðŸ› ï¸ Tools and tricks for error handling\n- ðŸš€ Performance boosts with indexing and partitioning\n\n---\n\n*Found this helpful? [Read the complete guide on Medium](https://medium.com/@shaunmia/simple-guide-to-bulk-inserts-indexing-and-optimizing-your-database-6dc7bce332e7)*"
    },
    {
      "id": 7,
      "slug": "easy-sql-exploration",
      "title": "7. Easy SQL for Exploring Data: Find Insights the Simple Way",
      "date": "May 4, 2025",
      "tags": [
        "SQL",
        "Data Analysis",
        "Data Exploration",
        "EDA",
        "Database",
        "Tutorial"
      ],
      "excerpt": "Learn how to effectively explore and analyze your data using simple SQL commands. A practical guide to data exploration for analysts and data scientists.",
      "medium": "https://medium.com/@shaunmia/easy-sql-for-exploring-data-find-insights-the-simple-way-b8f7e66ea982",
      "content": "[![Read on Medium](https://img.shields.io/badge/Read%20on-Medium-12100E?style=for-the-badge&logo=medium&logoColor=white)](https://medium.com/@shaunmia/easy-sql-for-exploring-data-find-insights-the-simple-way-b8f7e66ea982)\n\n## Introduction\n\nWhen you work with data, the first thing to do is **understand what's inside it**. This is called **Exploratory Data Analysis (EDA)**. It means taking a good look at your data before making charts or running advanced calculations.\n\nSQL is a great tool for this job. It helps you quickly **ask questions about your data** and find useful patterns. In this guide, you'll learn how to use simple SQL commands to explore your data step by step.\n\n## ðŸ” Looking at Your Data: Basic SQL Commands\n\nThese commands help you **choose, filter, and search** through your data.\n\n### âœ… `SELECT`: Pick the Data You Want\n\nUse `SELECT` to choose the columns (fields) you want to see.\n\n```sql\nSELECT name, age FROM employees;\n```\n\nThis shows the names and ages of all employees.\n\n### ðŸŽ¯ `WHERE`: Filter the Rows You Need\n\nUse `WHERE` to show only the rows that match a rule or condition.\n\n```sql\nSELECT * FROM employees WHERE age > 30;\n```\n\nThis shows all employees older than 30.\n\n### ðŸ”  `LIKE`: Find Words That Match a Pattern\n\nUse `LIKE` to find words that follow a pattern (for example, names starting with \"A\").\n\n```sql\nSELECT name FROM employees WHERE name LIKE 'A%';\n```\n\nThis shows names like \"Anna\", \"Alex\", etc.\n\n### ðŸ”¢ `BETWEEN`: Find Values in a Range\n\nUse `BETWEEN` to get results between two values like numbers or dates.\n\n```sql\nSELECT * FROM orders \nWHERE order_date BETWEEN '2023-01-01' AND '2023-06-30';\n```\n\n### ðŸš« `DISTINCT`: Remove Duplicates\n\nUse `DISTINCT` to see only **unique** values (no repeats).\n\n```sql\nSELECT DISTINCT department FROM employees;\n```\n\n## ðŸ“‹ Organizing Data: Sorting and Grouping\n\n### ðŸ”½ `ORDER BY`: Sort Your Data\n\n```sql\nSELECT * FROM products ORDER BY price DESC;\n```\n\nThis shows products from most expensive to cheapest.\n\n### ðŸ§® `GROUP BY`: Group and Summarize\n\n```sql\nSELECT department, COUNT(*) \nFROM employees \nGROUP BY department;\n```\n\n### ðŸš¦ `HAVING`: Filter Grouped Results\n\n```sql\nSELECT department, COUNT(*) AS employee_count\nFROM employees\nGROUP BY department\nHAVING COUNT(*) > 10;\n```\n\n### â³ `LIMIT`: Show a Few Rows Only\n\n```sql\nSELECT * FROM sales \nORDER BY amount DESC \nLIMIT 5;\n```\n\n## âž• Summarizing Data: Aggregate Functions\n\n### ðŸ”¢ `COUNT()`: Count the Rows\n\n```sql\nSELECT COUNT(*) FROM customers;\n```\n\n### âž• `SUM()`: Add Up Values\n\n```sql\nSELECT SUM(amount) FROM sales;\n```\n\n### ðŸ“Š `AVG()`: Find the Average\n\n```sql\nSELECT AVG(salary) FROM employees;\n```\n\n### ðŸ“‰ `MIN()` and `MAX()`: Lowest and Highest Values\n\n```sql\nSELECT MIN(age), MAX(age) FROM employees;\n```\n\n## ðŸ§  Putting It All Together: A Real Example\n\n```sql\nSELECT \n    department, \n    SUM(sales_amount) AS total_sales\nFROM transactions\nWHERE transaction_date \n    BETWEEN '2024-01-01' AND '2024-12-31'\nGROUP BY department\nHAVING COUNT(*) > 100\nORDER BY total_sales DESC\nLIMIT 3;\n```\n\n## âœ… Wrapping Up\n\nSQL makes it easy to explore and understand your data. With just a few simple commands, you can:\n\n* **Filter** what you need\n* **Sort** your results\n* **Group** similar data\n* **Summarize** using totals, averages, and counts\n\nEven if you're just starting out, using SQL for EDA will help you quickly spot patterns and answer important questions.\n\n---\n\n*Found this helpful? [Read the complete guide on Medium](https://medium.com/@shaunmia/easy-sql-for-exploring-data-find-insights-the-simple-way-b8f7e66ea982)*"
    },
    {
      "id": 8,
      "slug": "must-know-sql-functions",
      "title": "8. Must-Know Built-In SQL Functions for Data Analysts",
      "date": "May 10, 2025",
      "tags": [
        "SQL",
        "Database",
        "Data Analysis",
        "Functions",
        "Tutorial"
      ],
      "excerpt": "Master essential SQL built-in functions for data cleaning, transformation, and analysis. A practical guide covering date, string, type casting, and null handling functions.",
      "medium": "https://medium.com/@shaunmia/must-know-built-in-sql-functions-for-data-analysts-13db6cadeb1b",
      "content": "[![Read on Medium](https://img.shields.io/badge/Read%20on-Medium-12100E?style=for-the-badge&logo=medium&logoColor=white)](https://medium.com/@shaunmia/must-know-built-in-sql-functions-for-data-analysts-13db6cadeb1b)\n\n# Must-Know Built-In SQL Functions for Data Analysts\n\n### Super Useful SQL Tools to Clean, Organize, and Understand Your Data\n\nAs a data analyst, one of your biggest tasks is working with dataâ€”whether it's sales records, customer info, website logs, or survey responses. But this data often isn't perfect. Dates might be formatted strangely, text might be too long or messy, and numbers might be stored as text. That's where **built-in SQL functions** come in.\n\nSQL provides many handy functions to help you **clean**, **transform**, and **analyze** data directly in your queriesâ€”saving you time and making your analysis more accurate.\n\nIn this article, we'll cover the **must-know built-in SQL functions** every beginner data analyst should learn. We'll break them into 4 helpful categories:\n\n1. ðŸ•’ Date & Time Functions\n2. ðŸ”¤ String (Text) Functions\n3. ðŸ”„ Type Casting & Formatting\n4. ðŸš« Handling Missing or Null Data\n\nEach section includes **simple language**, **examples**, and **practical uses**.\n\n## ðŸ•’ 1. Date & Time Functions\n\nWorking with dates is super common in analyticsâ€”think about order dates, signup dates, or timestamps. SQL makes it easy to work with different parts of a date or convert text into date format.\n\n### ðŸ”¹ `EXTRACT()` â€“ Get Specific Parts of a Date\n\nThis function pulls out the **year**, **month**, **day**, or even **hour** from a full date.\n\n**Syntax:**\n\n```sql\nEXTRACT(part FROM date_column)\n```\n\n**Example 1: Get year from a date**\n\n```sql\nSELECT order_date, EXTRACT(YEAR FROM order_date) AS order_year\nFROM orders;\n```\n\n**Output:**\n\n| order_date | order_year |\n| ----------- | ----------- |\n| 2024-05-15  | 2024        |\n\n**Example 2: Get month from a date**\n\n```sql\nSELECT order_date, EXTRACT(MONTH FROM order_date) AS order_month\nFROM orders;\n```\n\n**Practical Uses:**\n\n* Grouping sales by month/year\n* Calculating age\n* Building time-series charts\n\n### ðŸ”¹ `TO_DATE()` â€“ Convert Text into a Real Date\n\nSometimes dates are stored as **text**, which can't be used in calculations or sorting. `TO_DATE()` fixes this.\n\n**Syntax:**\n\n```sql\nTO_DATE(text_date, 'format')\n```\n\n**Example 1:**\n\n```sql\nSELECT TO_DATE('2024-05-15', 'YYYY-MM-DD') AS real_date;\n```\n\n**Example 2:**\n\n```sql\nSELECT TO_DATE('15-May-2024', 'DD-Mon-YYYY') AS real_date;\n```\n\n**Practical Uses:**\n\n* Importing CSV/excel files with weird date formats\n* Making sure SQL recognizes a date correctly\n\n## ðŸ”¤ 2. String (Text) Functions\n\nText shows up a lotâ€”names, emails, product codes, etc. These functions help you clean, slice, and search text easily.\n\n### ðŸ”¹ `SUBSTRING()` â€“ Get a Part of the Text\n\nUse this to grab specific parts of a text value.\n\n**Syntax:**\n\n```sql\nSUBSTRING(text_column FROM start FOR length)\n```\n\n**Example:**\n\n```sql\nSELECT SUBSTRING('ShaunMia' FROM 1 FOR 5) AS short_name;\n-- Output: Shaun\n```\n\n**Example: Extract middle from product code**\n\n```sql\nSELECT SUBSTRING('ABC123XYZ' FROM 4 FOR 3) AS code_middle;\n-- Output: 123\n```\n\n**Practical Uses:**\n\n* Get initials or short names\n* Pull specific parts of a code\n* Trim messy inputs\n\n### ðŸ”¹ `POSITION()` â€“ Find Where a Character Is\n\nUse this to find the **position** of a character or word in a text.\n\n**Syntax:**\n\n```sql\nPOSITION('needle' IN 'haystack')\n```\n\n**Example: Find the \"@\" symbol in an email**\n\n```sql\nSELECT email, POSITION('@' IN email) AS at_pos\nFROM customers;\n```\n\n**Output:**\n\n| email | at_pos |\n| ----- | ------- |\n| alice@gmail.com | 6 |\n\n**Practical Uses:**\n\n* Find symbols (like @ in emails)\n* Help with splitting text\n* Check if a value exists in a string\n\n## ðŸ”„ 3. Type Casting & Formatting\n\nSometimes you need to **change the data type** or make it look nice in reports. These functions help you convert and format your data easily.\n\n### ðŸ”¹ `CAST()` â€“ Change One Type into Another\n\nTurn a number into text, or text into a number.\n\n**Syntax:**\n\n```sql\nCAST(column AS new_type)\n```\n\n**Example: Convert number to text**\n\n```sql\nSELECT 'Salary: ' || CAST(75000 AS TEXT) AS salary_text;\n-- Output: Salary: 75000\n```\n\n**Example: Convert text to number**\n\n```sql\nSELECT CAST('25' AS INTEGER) + 5 AS future_age;\n-- Output: 30\n```\n\n**Practical Uses:**\n\n* Prepare data for charts or labels\n* Fix wrong data types from imported files\n* Do calculations on text-based numbers\n\n### ðŸ”¹ `TO_CHAR()` â€“ Format Numbers or Dates as Text\n\nMake your numbers or dates look clean and readable.\n\n**Syntax:**\n\n```sql\nTO_CHAR(number_or_date, 'format')\n```\n\n**Example: Format a number**\n\n```sql\nSELECT TO_CHAR(1234567.89, '9,999,999.99') AS formatted_sales;\n-- Output: 1,234,567.89\n```\n\n**Example: Format a date**\n\n```sql\nSELECT TO_CHAR(order_date, 'DD-Mon-YYYY') AS nice_date\nFROM orders;\n```\n\n**Practical Uses:**\n\n* Beautiful dashboards\n* Export-ready reports\n* Custom formats in emails or PDFs\n\n## ðŸš« 4. Handling Missing or Null Data\n\nReal-world data often has **missing values**. These functions help you fill in, replace, or handle them safely.\n\n### ðŸ”¹ `COALESCE()` â€“ Replace NULL with Something\n\nThis function checks if a value is NULL and replaces it with something else.\n\n**Syntax:**\n\n```sql\nCOALESCE(column, 'default_value')\n```\n\n**Example: Replace NULL with 'Unknown'**\n\n```sql\nSELECT COALESCE(city, 'Unknown') AS customer_city\nFROM customers;\n```\n\n**Example: Replace NULL salary with 0**\n\n```sql\nSELECT COALESCE(salary, 0) AS clean_salary\nFROM employees;\n```\n\n**Practical Uses:**\n\n* Avoid errors in reports\n* Fill missing data with a default\n* Keep dashboards clean\n\n## âœ… Summary Table\n\n| Category | Function | Purpose |\n| -------- | -------- | ------- |\n| Date & Time | `EXTRACT()` | Pull out year/month/day from a date |\n| | `TO_DATE()` | Convert text into a proper date |\n| Text/String | `SUBSTRING()` | Extract part of a string |\n| | `POSITION()` | Find where something appears in a string |\n| Type Conversion | `CAST()` | Change one data type to another |\n| | `TO_CHAR()` | Format numbers/dates nicely as text |\n| Missing Data Handling | `COALESCE()` | Replace NULL values with defaults |\n\n## ðŸŽ¯ Final Tips for Beginners\n\n* **Practice** these functions on small datasets to get confident.\n* Combine functions for powerful results (e.g., use `COALESCE(TO_CHAR(...))`)\n* Always check your data types before converting\n* Use `TO_CHAR()` and `TO_DATE()` for reporting and cleaning dates\n* Use `SUBSTRING()` and `POSITION()` to fix or understand messy text\n\n---\n\n*Found this helpful? [Read the complete guide on Medium](https://medium.com/@shaunmia/must-know-built-in-sql-functions-for-data-analysts-13db6cadeb1b)*"
    },
    {
      "id": 9,
      "slug": "sql-joins-unions-case",
      "title": "9. Joins, Unions & Conditional Logic with CASE WHEN",
      "date": "May 11, 2025",
      "tags": [
        "SQL",
        "Database",
        "Data Analysis",
        "Tutorial",
        "Programming"
      ],
      "excerpt": "Master SQL joins, unions, and conditional logic using CASE WHEN statements. Learn how to combine data from multiple tables and handle complex business logic in your queries.",
      "medium": "https://medium.com/@shaunmia/joins-unions-conditional-logic-with-case-when-dc2c00d98182",
      "content": "[![Read on Medium](https://img.shields.io/badge/Read%20on-Medium-12100E?style=for-the-badge&logo=medium&logoColor=white)](https://medium.com/@shaunmia/joins-unions-conditional-logic-with-case-when-dc2c00d98182)\n\n## Introduction\n\nThis article provides an in-depth exploration of essential SQL concepts: Joins, Unions, and the CASE WHEN statement. Through detailed explanations and practical examples, it aims to enhance your understanding and application of these fundamental SQL operations.\n\n## ðŸ”— SQL Joins: INNER, LEFT, RIGHT, FULL\n\nSQL Joins are used to combine records from two or more tables based on related columns. Understanding the different types of joins is crucial for effective data retrieval.\n\n### 1. INNER JOIN\n\nDefinition: Returns records that have matching values in both tables.\n\n**Syntax:**\n```sql\nSELECT columns\nFROM table1\nINNER JOIN table2 ON table1.column = table2.column;\n```\n\n**Example:**\nAssuming we have customers and orders tables:\n```sql\nSELECT c.customer_name, o.order_id, o.order_amount\nFROM customers c\nINNER JOIN orders o ON c.customer_id = o.customer_id;\n```\n\nExplanation: This query retrieves only the customers who have placed orders, excluding those without any orders.\n\n### 2. LEFT JOIN (or LEFT OUTER JOIN)\n\nDefinition: Returns all records from the left table and the matched records from the right table. If there is no match, NULLs are returned for columns from the right table.\n\n**Syntax:**\n```sql\nSELECT columns\nFROM table1\nLEFT JOIN table2 ON table1.column = table2.column;\n```\n\n**Example:**\n```sql\nSELECT c.customer_name, o.order_id, o.order_amount\nFROM customers c\nLEFT JOIN orders o ON c.customer_id = o.customer_id;\n```\n\nExplanation: This query retrieves all customers, including those who haven't placed any orders. For customers without orders, the order details will be NULL.\n\n### 3. RIGHT JOIN (or RIGHT OUTER JOIN)\n\nDefinition: Returns all records from the right table and the matched records from the left table. If there is no match, NULLs are returned for columns from the left table.\n\n**Syntax:**\n```sql\nSELECT columns\nFROM table1\nRIGHT JOIN table2 ON table1.column = table2.column;\n```\n\n**Example:**\n```sql\nSELECT c.customer_name, o.order_id, o.order_amount\nFROM customers c\nRIGHT JOIN orders o ON c.customer_id = o.customer_id;\n```\n\nExplanation: This query retrieves all orders, including those that may not be associated with any customer. For such orders, customer details will be NULL.\n\n### 4. FULL JOIN (or FULL OUTER JOIN)\n\nDefinition: Returns all records when there is a match in either left or right table. Records without a match in one of the tables will have NULLs for the missing fields.\n\n**Syntax:**\n```sql\nSELECT columns\nFROM table1\nFULL JOIN table2 ON table1.column = table2.column;\n```\n\n**Example:**\n```sql\nSELECT c.customer_name, o.order_id, o.order_amount\nFROM customers c\nFULL JOIN orders o ON c.customer_id = o.customer_id;\n```\n\nExplanation: This query retrieves all customers and all orders, including customers without orders and orders without customers.\n\n## ðŸ” CROSS JOIN and Its Caveats\n\nDefinition: A CROSS JOIN returns the Cartesian product of two tables, combining each row of the first table with each row of the second table.\n\n**Syntax:**\n```sql\nSELECT columns\nFROM table1\nCROSS JOIN table2;\n```\n\n**Example:**\nAssuming we have products and stores tables:\n```sql\nSELECT p.product_name, s.store_name\nFROM products p\nCROSS JOIN stores s;\n```\n\nExplanation: This query generates all possible combinations of products and stores. If there are 3 products and 2 stores, the result will have 6 rows.\n\nCaution: Use CROSS JOINs carefully, especially with large tables, as the result set can grow exponentially.\n\n## ðŸ”€ UNION vs UNION ALL\n\nBoth UNION and UNION ALL are used to combine the results of two or more SELECT statements.\n\n### âœ… UNION\n\nDefinition: Combines the results of two SELECT statements and removes duplicate rows.\n\n**Syntax:**\n```sql\nSELECT column FROM table1\nUNION\nSELECT column FROM table2;\n```\n\n**Example:**\n```sql\nSELECT name FROM old_clients\nUNION\nSELECT name FROM new_clients;\n```\n\nExplanation: This query returns a list of unique client names from both tables.\n\n### ðŸš€ UNION ALL\n\nDefinition: Combines the results of two SELECT statements and includes all duplicate rows.\n\n**Syntax:**\n```sql\nSELECT column FROM table1\nUNION ALL\nSELECT column FROM table2;\n```\n\n**Example:**\n```sql\nSELECT name FROM old_clients\nUNION ALL\nSELECT name FROM new_clients;\n```\n\nExplanation: This query returns all client names from both tables, including duplicates.\n\nPerformance Note: UNION ALL is generally faster than UNION because it doesn't perform the duplicate elimination step.\n\n## ðŸ§  Practical Use of CASE WHEN\n\nThe CASE WHEN statement in SQL allows for conditional logic within queries, similar to IF-THEN-ELSE statements in programming languages.\n\n### ðŸ”§ Example 1: Categorize Orders\n\nScenario: Classify orders based on quantity.\n\n```sql\nSELECT \n    order_id,\n    quantity,\n    CASE \n        WHEN quantity >= 100 THEN 'Large'\n        WHEN quantity >= 50 THEN 'Medium'\n        ELSE 'Small'\n    END AS order_size\nFROM orders;\n```\n\nExplanation: This query categorizes each order as 'Large', 'Medium', or 'Small' based on the quantity.\n\n### ðŸ”„ Example 2: Replace NULL with Custom Value\n\nScenario: Handle missing phone numbers in a customer table.\n\n```sql\nSELECT \n    customer_name,\n    CASE \n        WHEN phone IS NULL THEN 'No phone provided'\n        ELSE phone \n    END AS contact\nFROM customers;\n```\n\nExplanation: This query replaces NULL phone numbers with the text 'No phone provided'.\n\n### ðŸ”„ Example 3: Nested CASE WHEN\n\nScenario: Assign priority levels based on order amount and quantity.\n\n```sql\nSELECT \n    order_id,\n    order_amount,\n    quantity,\n    CASE \n        WHEN order_amount > 1000 THEN \n            CASE \n                WHEN quantity > 50 THEN 'High Priority'\n                ELSE 'Medium Priority'\n            END\n        ELSE 'Low Priority'\n    END AS priority\nFROM orders;\n```\n\nExplanation: This query assigns a priority level to each order based on the amount and quantity, using nested CASE statements for more complex logic.\n\n## ðŸ§© Summary and Practical Applications\n\n| Feature | Use Case | Key Consideration |\n|---------|----------|-------------------|\n| INNER JOIN | Match rows from both tables | Only includes matched records |\n| LEFT JOIN | Keep all rows from left table | Useful for identifying missing matches |\n| RIGHT JOIN | Keep all rows from right table | Focuses on right table data |\n| FULL JOIN | Combine all rows, matched or unmatched | Ideal for data reconciliation |\n| CROSS JOIN | All combinations | Use cautiously with large datasets |\n| UNION | Combine results, remove duplicates | Ensures unique records |\n| UNION ALL | Combine all results, keep duplicates | Faster, includes all records |\n| CASE WHEN | Conditional logic for transformations | Versatile for categorization and cleaning |\n\n### Real-World Applications:\n\n- **Retail**: Use LEFT JOIN to identify customers without recent purchases and CASE WHEN to segment them by purchase history.\n- **Finance**: Use FULL JOIN to reconcile transactions between systems and UNION to merge transaction logs.\n- **Marketing**: Use CROSS JOIN to generate all possible campaign-product combinations and CASE WHEN to assign campaign priorities.\n\n## ðŸ§© âœ… Practice Tip\n\nTo master these concepts, try the following exercises:\n\n1. **Joins**: Create two tables (e.g., employees and departments). Write queries using INNER, LEFT, RIGHT, and FULL JOINs to explore relationships and handle missing data.\n\n2. **UNION / UNION ALL**: Combine data from two similar tables (e.g., sales_2024 and sales_2025). Compare UNION vs. UNION ALL resultsâ€”observe how UNION removes duplicates while UNION ALL retains them. Analyze performance differences on large datasets.\n\n3. **CASE WHEN**: Use CASE WHEN to create conditional columns. For example, in a sales table, create a new column that classifies sales amounts:\n\n```sql\nSELECT \n  order_id,\n  amount,\n  CASE \n    WHEN amount >= 1000 THEN 'High'\n    WHEN amount >= 500 THEN 'Medium'\n    ELSE 'Low'\n  END AS sales_category\nFROM sales;\n```\n\nPractice multiple conditions, nesting, and using CASE in ORDER BY and GROUP BY.\n\n---\n\n*Found this helpful? [Read the complete guide on Medium](https://medium.com/@shaunmia/joins-unions-conditional-logic-with-case-when-dc2c00d98182)*"
    },
    {
      "id": 10,
      "slug": "subqueries-ctes-rfm",
      "title": "10. Subqueries, CTEs & RFM Segmentation with SQL",
      "date": "May 16, 2025",
      "tags": [
        "SQL",
        "Database",
        "Data Analysis",
        "Tutorial",
        "Segmentation"
      ],
      "excerpt": "Learn how to organize complex SQL queries using subqueries and CTEs, and implement customer segmentation using RFM analysis. A practical guide with real-world examples.",
      "medium": "https://medium.com/@shaunmia/subqueries-ctes-rfm-segmentation-with-sql-cb711e8b0a4b",
      "content": "[![Read on Medium](https://img.shields.io/badge/Read%20on-Medium-12100E?style=for-the-badge&logo=medium&logoColor=white)](https://medium.com/@shaunmia/subqueries-ctes-rfm-segmentation-with-sql-cb711e8b0a4b)\n\n# Subqueries, CTEs & RFM Segmentation with SQL\n\n### Learn How to Organize Your SQL Code and Segment Customers Like a Pro\n\nWhen working with data, especially in large or messy databases, you'll often need to write long or complex SQL queries. Thankfully, **Subqueries** and **CTEs (Common Table Expressions)** help break things down, so your queries stay clean, readable, and easy to maintain.\n\nIn this article, we'll learn:\n\n* What subqueries and CTEs are\n* When to use one over the other\n* How to create and use views\n* A practical customer segmentation technique called **RFM Analysis** using SQL\n\nLet's jump in!\n\n## ðŸ§© What is a Subquery?\n\nA **subquery** is a SQL query inside another SQL query. It's usually used when you need the result of one query to help filter or calculate things in another.\n\nThink of it like asking a question within a question:\n\n**Example**:\n\"Show me all customers whose total order amount is above the average order amount.\"\n\nTo do that, we need to:\n\n1. Calculate the average order amount (that's one query).\n2. Get all customers with orders greater than that (the outer query).\n\n### âœ… Example:\n\n```sql\nSELECT customer_id, total_amount\nFROM orders\nWHERE total_amount > (\n    SELECT AVG(total_amount)\n    FROM orders\n);\n```\n\nThis subquery calculates the average order, and the main query filters customers above that average.\n\n### ðŸ§  Use Cases:\n\n* Filtering using calculated values\n* Correlated subqueries (where the inner query depends on outer query rows)\n* Aggregating data dynamically\n\n## ðŸ”„ What is a CTE (Common Table Expression)?\n\nA **CTE** is like a temporary result set you define **at the top of your SQL query**, which you can refer to laterâ€”just like a temporary table.\n\nIt starts with the keyword `WITH`, and it helps simplify big, messy SQL code.\n\n### âœ… Example:\n\nLet's say we want to find customers with more than 3 orders.\n\n```sql\nWITH customer_orders AS (\n    SELECT customer_id, COUNT(*) AS order_count\n    FROM orders\n    GROUP BY customer_id\n)\nSELECT *\nFROM customer_orders\nWHERE order_count > 3;\n```\n\n### ðŸ’¡ Why Use CTEs?\n\n* Makes long SQL queries readable\n* You can define multiple steps clearly\n* Easier to debug and reuse\n\n## ðŸ†š Subquery vs. CTE â€“ Which is Better?\n\n| Feature     | Subquery                      | CTE                               |\n| ----------- | ----------------------------- | --------------------------------- |\n| Location    | Inside WHERE, SELECT, etc.    | Defined at the top using `WITH`   |\n| Readability | Can get messy in long queries | Easier to read and manage         |\n| Reusability | Usually not reusable          | Can reuse multiple times          |\n| Performance | Often similar                 | Slightly better with complex data |\n\n**ðŸ‘‰ Rule of Thumb**:\n\n* Use **subqueries** for quick one-off filtering or calculations.\n* Use **CTEs** when things get complex or when you want to break the logic into clear steps.\n\n## ðŸ‘€ What is a SQL View?\n\nA **view** is like a saved SQL query that you can use just like a table. It doesn't store the data itselfâ€”it just remembers the logic to generate it.\n\n### âœ… Creating a View:\n\n```sql\nCREATE VIEW high_value_customers AS\nSELECT customer_id, SUM(order_amount) AS total_spent\nFROM orders\nGROUP BY customer_id\nHAVING total_spent > 1000;\n```\n\nNow you can simply use:\n\n```sql\nSELECT * FROM high_value_customers;\n```\n\n**Benefits**:\n\n* You don't need to rewrite complex queries every time\n* Makes SQL reports easier to manage\n* Keeps your SQL code DRY (Don't Repeat Yourself)\n\n## ðŸ“Š RFM Segmentation Using SQL\n\n**RFM = Recency, Frequency, Monetary**\n\nIt's a marketing technique to group customers based on:\n\n* **Recency**: How recently they purchased\n* **Frequency**: How often they purchase\n* **Monetary**: How much they spend\n\n### ðŸ”§ Step-by-Step SQL RFM Example\n\nLet's assume we have a table called `orders`:\n\n```sql\norder_id | customer_id | order_date | order_amount\n--------------------------------------------------\n```\n\n### âœ… Step 1: Get the last order date (Recency), total orders (Frequency), and total spent (Monetary)\n\n```sql\nWITH rfm_raw AS (\n    SELECT \n        customer_id,\n        MAX(order_date) AS last_order_date,\n        COUNT(order_id) AS frequency,\n        SUM(order_amount) AS monetary\n    FROM orders\n    GROUP BY customer_id\n)\nSELECT *,\n    DATEDIFF(CURRENT_DATE, last_order_date) AS recency\nFROM rfm_raw;\n```\n\nHere's what each field means:\n\n* **Recency** = days since last purchase (lower is better)\n* **Frequency** = how many times they purchased (higher is better)\n* **Monetary** = total amount spent (higher is better)\n\n### âœ… Step 2: Add scoring to each RFM metric\n\nYou can use `CASE WHEN` to rank customers:\n\n```sql\nWITH rfm_raw AS (\n    SELECT \n        customer_id,\n        MAX(order_date) AS last_order_date,\n        COUNT(order_id) AS frequency,\n        SUM(order_amount) AS monetary\n    FROM orders\n    GROUP BY customer_id\n),\nrfm_scored AS (\n    SELECT *,\n        DATEDIFF(CURRENT_DATE, last_order_date) AS recency,\n        CASE \n            WHEN DATEDIFF(CURRENT_DATE, last_order_date) <= 30 THEN 5\n            WHEN DATEDIFF(CURRENT_DATE, last_order_date) <= 60 THEN 4\n            WHEN DATEDIFF(CURRENT_DATE, last_order_date) <= 90 THEN 3\n            WHEN DATEDIFF(CURRENT_DATE, last_order_date) <= 180 THEN 2\n            ELSE 1\n        END AS recency_score,\n        CASE \n            WHEN frequency >= 10 THEN 5\n            WHEN frequency >= 7 THEN 4\n            WHEN frequency >= 4 THEN 3\n            WHEN frequency >= 2 THEN 2\n            ELSE 1\n        END AS frequency_score,\n        CASE \n            WHEN monetary >= 1000 THEN 5\n            WHEN monetary >= 750 THEN 4\n            WHEN monetary >= 500 THEN 3\n            WHEN monetary >= 250 THEN 2\n            ELSE 1\n        END AS monetary_score\n    FROM rfm_raw\n)\nSELECT *\nFROM rfm_scored;\n```\n\nThis gives you a full **RFM score** for each customer.\n\nYou can go further by creating a combined score:\n\n```sql\nSELECT *,\n       recency_score + frequency_score + monetary_score AS rfm_score\nFROM rfm_scored;\n```\n\n## ðŸ Wrap-Up\n\nHere's what you learned:\n\nâœ… **Subqueries**: Write queries inside other queries to filter or calculate results\nâœ… **CTEs**: Break complex queries into cleaner steps with `WITH`\nâœ… **Views**: Save common queries like a virtual table\nâœ… **RFM Segmentation**: Analyze customer behavior by how recent, frequent, and valuable their purchases are\n\n## âœ… Final Challenge: Practice These Concepts\n\n1. **Use `ROW_NUMBER()`** to find each customer's first purchase.\n2. **Use `LAG()`** to calculate revenue change between orders.\n3. **Build a Cohort Table** for a signup + login dataset.\n4. **Plot a MoM trend** of sales using `LAG()` and `window functions`.\n5. **Use Colab + BigQuery** to combine Python and SQL together.\n\n---\n\n*Found this helpful? [Read the complete guide on Medium](https://medium.com/@shaunmia/subqueries-ctes-rfm-segmentation-with-sql-cb711e8b0a4b)*"
    },
    {
      "id": 11,
      "slug": "mastering-sql-ctes",
      "title": "11. Mastering SQL CTEs: Simplifying Complex Queries with Ease",
      "date": "May 16, 2025",
      "tags": [
        "SQL",
        "Database",
        "CTEs",
        "Data Analysis",
        "Technical Guide"
      ],
      "excerpt": "Learn how to use Common Table Expressions (CTEs) to write cleaner and more maintainable SQL queries, with practical examples and best practices.",
      "medium": "https://medium.com/@shaunmia/mastering-sql-ctes-simplifying-complex-queries-with-ease-f2321cae7447",
      "content": "[![Read on Medium](https://img.shields.io/badge/Read%20on-Medium-12100E?style=for-the-badge&logo=medium&logoColor=white)](https://medium.com/@shaunmia/mastering-sql-ctes-simplifying-complex-queries-with-ease-f2321cae7447)\n\n## Introduction\n\nStructured Query Language (SQL) is the backbone of modern data management. Among its many powerful features, Common Table Expressions (CTEs) stand out as an elegant solution for handling complex queries. In this comprehensive guide, we'll explore how CTEs can transform your SQL code into more maintainable and efficient solutions.\n\n## What Are Common Table Expressions?\n\nCommon Table Expressions (CTEs) are temporary named result sets that exist within the scope of a single SQL statement. Think of them as virtual tables that you can reference multiple times within your query. They're particularly useful for:\n\n- Breaking down complex queries into manageable pieces\n- Improving code readability and maintenance\n- Enabling recursive queries\n- Simplifying subquery logic\n\n## Basic CTE Syntax\n\n```sql\nWITH CTE_Name AS (\n    -- CTE query definition\n    SELECT column1, column2\n    FROM table_name\n    WHERE condition\n)\nSELECT *\nFROM CTE_Name;\n```\n\n## Real-World Examples\n\n### 1. Finding Top Performing Products\n\n```sql\nWITH ProductPerformance AS (\n    SELECT \n        product_id,\n        product_name,\n        SUM(sales_amount) as total_sales,\n        COUNT(order_id) as order_count\n    FROM sales_data\n    GROUP BY product_id, product_name\n)\nSELECT *\nFROM ProductPerformance\nWHERE total_sales > 100000\nORDER BY total_sales DESC;\n```\n\n### 2. Recursive Employee Hierarchy\n\n```sql\nWITH RECURSIVE EmployeeHierarchy AS (\n    -- Base case: top-level employees\n    SELECT employee_id, name, manager_id, 1 as level\n    FROM employees\n    WHERE manager_id IS NULL\n    \n    UNION ALL\n    \n    -- Recursive case: employees with managers\n    SELECT e.employee_id, e.name, e.manager_id, eh.level + 1\n    FROM employees e\n    INNER JOIN EmployeeHierarchy eh \n    ON e.manager_id = eh.employee_id\n)\nSELECT * FROM EmployeeHierarchy;\n```\n\n## Advanced Techniques\n\n### Multiple CTEs\n\n```sql\nWITH CustomerMetrics AS (\n    SELECT \n        customer_id,\n        COUNT(*) as order_count,\n        SUM(order_total) as total_spent\n    FROM orders\n    GROUP BY customer_id\n),\nHighValueCustomers AS (\n    SELECT *\n    FROM CustomerMetrics\n    WHERE total_spent > 10000\n)\nSELECT \n    c.customer_name,\n    h.order_count,\n    h.total_spent\nFROM HighValueCustomers h\nJOIN customers c ON h.customer_id = c.customer_id;\n```\n\n## Best Practices\n\n1. **Naming Conventions**\n   - Use clear, descriptive names\n   - Follow a consistent naming pattern\n   - Indicate the purpose of the CTE\n\n2. **Code Organization**\n   - Keep CTE definitions focused and single-purpose\n   - Order CTEs logically\n   - Comment complex logic\n\n3. **Performance Considerations**\n   - Use indexes effectively\n   - Avoid unnecessary computations\n   - Consider materialized views for frequently used CTEs\n\n4. **Debugging Tips**\n   - Test CTEs independently\n   - Use EXPLAIN PLAN to analyze performance\n   - Break down complex CTEs into smaller parts\n\n## Common Pitfalls to Avoid\n\n1. Over-complicated CTEs\n2. Recursive CTEs without proper termination conditions\n3. Unnecessary nesting of CTEs\n4. Poor naming conventions\n\n## Real-World Use Cases\n\n1. **Financial Analysis**\n   - Rolling calculations\n   - Period-over-period comparisons\n   - Cumulative totals\n\n2. **Customer Segmentation**\n   - RFM analysis\n   - Customer lifetime value\n   - Cohort analysis\n\n3. **Inventory Management**\n   - Stock level tracking\n   - Reorder point calculations\n   - Supply chain analysis\n\n## Performance Tips\n\n1. Use appropriate indexes\n2. Minimize data scanning\n3. Optimize JOIN conditions\n4. Consider materialization when appropriate\n\n## Conclusion\n\nCTEs are powerful tools that can significantly improve your SQL code quality and maintainability. By following these best practices and understanding their capabilities, you can write more efficient and readable queries that are easier to maintain and debug.\n\n## Further Resources\n\n- [SQL Documentation](https://docs.microsoft.com/en-us/sql/)\n- [PostgreSQL CTE Guide](https://www.postgresql.org/docs/current/queries-with.html)\n- [Advanced SQL Techniques](https://modern-sql.com/)\n\n---\n\n*ðŸ’¡ Found this helpful? [Read the full article on Medium](https://medium.com/@shaunmia/mastering-sql-ctes-simplifying-complex-queries-with-ease-f2321cae7447)*"
    },
    {
      "id": 12,
      "slug": "sql-subqueries",
      "title": "12. Unlocking the Power of Subqueries in SQL",
      "date": "May 17, 2025",
      "tags": [
        "SQL",
        "Database",
        "Subqueries",
        "Data Analysis"
      ],
      "excerpt": "Master the art of writing efficient SQL subqueries to solve complex data problems with practical examples and best practices.",
      "medium": "https://medium.com/@shaunmia/unlocking-the-power-of-subqueries-in-sql-f83383f2e754",
      "content": "[![Read on Medium](https://img.shields.io/badge/Read%20on-Medium-12100E?style=for-the-badge&logo=medium&logoColor=white)](https://medium.com/@shaunmia/unlocking-the-power-of-subqueries-in-sql-f83383f2e754)\n\n## Introduction\n\nSQL is a versatile language that allows for complex data manipulation and retrieval. Among its many powerful features, subqueries are an essential tool for solving multi-step problems within a single SQL statement. Subqueries enable breaking down complex tasks into smaller, manageable components, making it easier to write, debug, and maintain SQL queries.\n\n## What Are Subqueries?\n\nA subquery is a SQL query nested inside another query. It is used to return data that will be used by the main query as a condition to further restrict or filter the result set. Subqueries can appear in various clauses such as SELECT, FROM, WHERE, and even HAVING.\n\n## Types of Subqueries\n\n1. **Single-Row Subqueries**: Returns a single value to the main query\n2. **Multi-Row Subqueries**: Returns multiple values for use with operators like IN or ANY\n3. **Correlated Subqueries**: Depends on values from the outer query for its execution\n4. **Nested Subqueries**: Subqueries within subqueries, used for highly complex filtering\n\n## Basic Syntax\n\n```sql\nSELECT column_name\nFROM table_name\nWHERE column_name OPERATOR (\n    SELECT column_name\n    FROM table_name\n    WHERE condition\n);\n```\n\n## Practical Examples\n\n### 1. Find Customers Who Placed Orders in 2023\n```sql\nSELECT name\nFROM Customers\nWHERE customer_id IN (\n    SELECT customer_id\n    FROM Orders\n    WHERE YEAR(order_date) = 2023\n);\n```\n\n### 2. Identify Products Never Ordered\n```sql\nSELECT product_name\nFROM Products\nWHERE product_id NOT IN (\n    SELECT product_id\n    FROM OrderDetails\n);\n```\n\n### 3. Get Customer with Highest Order Value\n```sql\nSELECT name\nFROM Customers\nWHERE customer_id = (\n    SELECT customer_id\n    FROM Orders\n    ORDER BY total_amount DESC\n    LIMIT 1\n);\n```\n\n## Best Practices\n\n1. **Performance Optimization**\n   - Avoid overusing subqueries\n   - Use indexes effectively\n   - Consider JOINs when appropriate\n   - Test query performance\n\n2. **Code Organization**\n   - Keep subqueries simple\n   - Use clear naming conventions\n   - Comment complex logic\n   - Break down large queries\n\n3. **Debugging Strategy**\n   - Test subqueries independently\n   - Use EXPLAIN PLAN\n   - Monitor execution time\n   - Validate results carefully\n\n## Common Use Cases\n\n1. **Data Filtering**\n   - Complex WHERE conditions\n   - Dynamic criteria selection \n   - Multi-table filtering\n   - Exclusion logic\n\n2. **Aggregations**\n   - Calculated comparisons\n   - Running totals\n   - Complex grouping\n   - Conditional summaries\n\n3. **Advanced Analysis**\n   - Trend detection\n   - Pattern matching\n   - Hierarchical data\n   - Time-based analysis\n\n## Performance Tips\n\n1. ðŸš€ Optimize index usage\n2. ðŸ“Š Minimize nested levels\n3. âš¡ Use EXISTS when appropriate\n4. ðŸ” Consider materialized views\n\n## Additional Resources\n\n- ðŸ“š [SQL Documentation](https://docs.microsoft.com/en-us/sql/)\n- ðŸŽ“ [Practice Exercises](https://www.postgresql.org/docs/current/queries-with.html)\n- ðŸ’¡ [Advanced Techniques](https://modern-sql.com/)\n\n---\n\n*Found this helpful? [Read the complete guide on Medium](https://medium.com/@shaunmia/unlocking-the-power-of-subqueries-in-sql-f83383f2e754)*"
    },
    {
      "id": 13,
      "slug": "advanced-sql-windows",
      "title": "13. Advanced SQL â€“ Window Functions & Cohort Analysis",
      "date": "May 18, 2025",
      "tags": [
        "SQL",
        "Database",
        "Analytics",
        "Window Functions",
        "Cohort Analysis",
        "BigQuery"
      ],
      "excerpt": "Master SQL window functions and cohort analysis with practical examples. Learn how to use ROW_NUMBER, RANK, LEAD/LAG functions, and perform customer retention analysis.",
      "medium": "https://medium.com/@shaunmia/advanced-sql-window-functions-cohort-analysis-400684dfd25b",
      "content": "[![Read on Medium](https://img.shields.io/badge/Read%20on-Medium-12100E?style=for-the-badge&logo=medium&logoColor=white)](https://medium.com/@shaunmia/advanced-sql-window-functions-cohort-analysis-400684dfd25b)\n\n### Mastering Ranking, Time-Based Insights & Customer Retention in SQL\n\nAs you dive deeper into SQL, you'll find that **basic queries** (like `GROUP BY`, `COUNT()`, or `JOIN`) are helpfulâ€”but not always enough when you want to do advanced analytics.\n\nThat's where **Window Functions** and **Cohort Analysis** come in.\n\nIn this final article of the series, we'll cover:\n\nâœ… Ranking with `ROW_NUMBER`, `RANK`, `DENSE_RANK`\nâœ… Looking forward and backward with `LEAD`, `LAG`, `FIRST_VALUE`\nâœ… Tracking changes over time: moving average & month-over-month (MoM)\nâœ… Performing **Cohort Analysis** using SQL\nâœ… A quick bonus on using **Google Colab + BigQuery** together\n\nLet's break it down in simple terms!\n\n## ðŸ§  What is a Window Function?\n\nA **Window Function** lets you **do calculations across rows** that are somehow relatedâ€”without grouping them into a single row like `GROUP BY` does.\n\nImagine looking at a spreadsheet and writing notes next to each row like:\n\n* \"You're the 2nd highest sale this month!\"\n* \"Your revenue is $500 more than the previous order.\"\n\nThat's what window functions allow you to doâ€”in **SQL**, inside your query.\n\n## ðŸ”¢ Part 1: Ranking Rows â€“ ROW_NUMBER, RANK, DENSE_RANK\n\nThese functions help you assign a **rank or position** to each row in a group.\n\n### ðŸ§® `ROW_NUMBER()`\n\nGives each row a unique number in a group, **even if values are tied**.\n\n```sql\nSELECT \n  customer_id, \n  order_amount,\n  ROW_NUMBER() OVER (ORDER BY order_amount DESC) AS row_num\nFROM orders;\n```\n\n### ðŸ§® `RANK()`\n\nRanks rows, but **ties get the same rank**, and **next rank is skipped**.\n\n```sql\nRANK() OVER (ORDER BY order_amount DESC)\n```\n\n### ðŸ§® `DENSE_RANK()`\n\nSimilar to `RANK()` but **does not skip numbers**.\n\n```sql\nDENSE_RANK() OVER (ORDER BY order_amount DESC)\n```\n\n**Use Case**: Find top 5 customers per month or best-selling products by ranking them.\n\n## âª Part 2: LEAD, LAG & FIRST_VALUE\n\nThese functions help you **compare data between rows** without writing self-joins.\n\n### ðŸ”¼ `LEAD()`: See the \"next\" row\n\n```sql\nLEAD(order_amount) OVER (ORDER BY order_date)\n```\n\nGives you the next order's amount (same table, different row).\n\n### ðŸ”½ `LAG()`: See the \"previous\" row\n\n```sql\nLAG(order_amount) OVER (ORDER BY order_date)\n```\n\nLets you compare each row to the one before it.\n\n### ðŸ¥‡ `FIRST_VALUE()`: Always shows the **first** value in the window\n\n```sql\nFIRST_VALUE(order_amount) OVER (PARTITION BY customer_id ORDER BY order_date)\n```\n\nFinds the first order amount for every customer.\n\n**Use Case**:\n\n* Compare current vs previous order\n* Calculate change from one row to the next\n* Understand customer's first purchase\n\n## ðŸ“‰ Part 3: Moving Average & MoM Change (Time-Based Trends)\n\nThese functions are great for **time-series data**, like daily sales or monthly revenue.\n\n### ðŸ”„ Moving Average\n\nA **moving average** smooths out data by calculating the average over the last few rows.\n\n```sql\nSELECT \n  order_date,\n  SUM(order_amount) OVER (\n    ORDER BY order_date \n    ROWS BETWEEN 2 PRECEDING AND CURRENT ROW\n  ) / 3 AS moving_avg\nFROM orders;\n```\n\nâ†’ This gives the average of the **current day + last 2 days**.\n\n### ðŸ“ˆ Month-over-Month (MoM) Change\n\nYou can calculate the **percent change from last month** using `LAG()`.\n\n```sql\nSELECT \n  month,\n  revenue,\n  LAG(revenue) OVER (ORDER BY month) AS prev_month,\n  (revenue - LAG(revenue) OVER (ORDER BY month)) / LAG(revenue) OVER (ORDER BY month) * 100 AS mom_change\nFROM monthly_revenue;\n```\n\n**Use Case**:\n\n* Track growth\n* Detect drops or spikes in sales\n* Visualize trends on dashboards\n\n## ðŸ“Š Part 4: Cohort Analysis Using SQL\n\n**Cohort Analysis** helps you track groups of users over timeâ€”especially useful for **retention analysis**.\n\n### ðŸ§¾ What's a Cohort?\n\nA **cohort** is a group of users who share something in commonâ€”like the month they signed up.\n\n**Goal**: See how many users from each cohort are still active after 1, 2, 3 months, etc.\n\n### âœ… Step-by-Step Example:\n\nAssume you have a `users` table and a `logins` table.\n\n#### Step 1: Assign a cohort based on signup month\n\n```sql\nWITH user_cohort AS (\n  SELECT \n    user_id,\n    DATE_TRUNC('month', signup_date) AS cohort_month\n  FROM users\n)\n```\n\n#### Step 2: Calculate how many months since signup\n\n```sql\n, login_activity AS (\n  SELECT \n    l.user_id,\n    DATE_TRUNC('month', login_date) AS login_month\n  FROM logins l\n)\n```\n\n#### Step 3: Combine the two and calculate \"month number\"\n\n```sql\n, combined AS (\n  SELECT \n    uc.user_id,\n    uc.cohort_month,\n    la.login_month,\n    DATE_DIFF(la.login_month, uc.cohort_month, MONTH) AS month_number\n  FROM user_cohort uc\n  JOIN login_activity la ON uc.user_id = la.user_id\n)\n```\n\n#### Step 4: Count how many users came back in each month\n\n```sql\nSELECT \n  cohort_month,\n  month_number,\n  COUNT(DISTINCT user_id) AS active_users\nFROM combined\nGROUP BY cohort_month, month_number\nORDER BY cohort_month, month_number;\n```\n\n**This gives you a full Cohort Table!**\n\nYou can now use this for:\n\n* Retention rate calculations\n* Visual heatmaps in dashboards\n* Marketing campaign performance tracking\n\n## ðŸ¤– Bonus: Google Colab + BigQuery Integration\n\nIf you want to analyze big data with Python + SQL:\n\n1. Use **Google BigQuery** to store your data.\n2. Connect it to **Google Colab** using the BigQuery magic commands:\n\n```python\nfrom google.colab import auth\nauth.authenticate_user()\n\n# Run SQL query using BigQuery\n%load_ext google.cloud.bigquery\n%%bigquery df\nSELECT * FROM `your_project.dataset.table` LIMIT 10\n```\n\nNow you can:\n\n* Run SQL\n* Analyze with pandas\n* Visualize in Python\n\nGreat for data science workflows and dashboards!\n\n## ðŸ§  Summary\n\n| Concept         | What It Does                             | Use Cases                         |\n| --------------- | ---------------------------------------- | --------------------------------- |\n| `ROW_NUMBER()`  | Assigns unique row numbers               | Ranking, pagination               |\n| `RANK()`        | Ranks with gaps for ties                 | Leaderboards, performance metrics |\n| `DENSE_RANK()`  | Ranks without skipping numbers           | Reporting ranks                   |\n| `LEAD()`        | Get value from next row                  | Compare current vs future values  |\n| `LAG()`         | Get value from previous row              | Compare current vs past           |\n| `FIRST_VALUE()` | Gets the first value in a partition      | Track first event                 |\n| Moving Avg      | Averages over past rows                  | Smoothing time trends             |\n| MoM Change      | Calculates percent change month-to-month | Growth trends                     |\n| Cohort Analysis | Tracks group behavior over time          | Retention, churn, loyalty         |\n\n## âœ… Final Challenge: Practice These Concepts\n\n1. **Use `ROW_NUMBER()`** to find each customer's first purchase.\n2. **Use `LAG()`** to calculate revenue change between orders.\n3. **Build a Cohort Table** for a signup + login dataset.\n4. **Plot a MoM trend** of sales using `LAG()` and `window functions`.\n5. **Use Colab + BigQuery** to combine Python and SQL together.\n\n---\n\n*Found this helpful? [Read the complete guide on Medium](https://medium.com/@shaunmia/advanced-sql-window-functions-cohort-analysis-400684dfd25b)*"
    }
  ]
}